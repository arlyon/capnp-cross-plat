// Code generated by capnpc-go. DO NOT EDIT.

package main

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type TaskHashable capnp.Struct

// TaskHashable_TypeID is the unique identifier for the type TaskHashable.
const TaskHashable_TypeID = 0xe1f09ceb4ef5e479

func NewTaskHashable(s *capnp.Segment) (TaskHashable, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 13})
	return TaskHashable(st), err
}

func NewRootTaskHashable(s *capnp.Segment) (TaskHashable, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 13})
	return TaskHashable(st), err
}

func ReadRootTaskHashable(msg *capnp.Message) (TaskHashable, error) {
	root, err := msg.Root()
	return TaskHashable(root.Struct()), err
}

func (s TaskHashable) String() string {
	str, _ := text.Marshal(0xe1f09ceb4ef5e479, capnp.Struct(s))
	return str
}

func (s TaskHashable) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TaskHashable) DecodeFromPtr(p capnp.Ptr) TaskHashable {
	return TaskHashable(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TaskHashable) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TaskHashable) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TaskHashable) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TaskHashable) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TaskHashable) GlobalHash() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s TaskHashable) HasGlobalHash() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TaskHashable) GlobalHashBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s TaskHashable) SetGlobalHash(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s TaskHashable) TaskDependencyHashes() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasTaskDependencyHashes() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TaskHashable) SetTaskDependencyHashes(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewTaskDependencyHashes sets the taskDependencyHashes field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewTaskDependencyHashes(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s TaskHashable) PackageDir() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s TaskHashable) HasPackageDir() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s TaskHashable) PackageDirBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s TaskHashable) SetPackageDir(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s TaskHashable) HashOfFiles() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s TaskHashable) HasHashOfFiles() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s TaskHashable) HashOfFilesBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s TaskHashable) SetHashOfFiles(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s TaskHashable) ExternalDepsHash() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s TaskHashable) HasExternalDepsHash() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s TaskHashable) ExternalDepsHashBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s TaskHashable) SetExternalDepsHash(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s TaskHashable) Task() (string, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return p.Text(), err
}

func (s TaskHashable) HasTask() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s TaskHashable) TaskBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return p.TextBytes(), err
}

func (s TaskHashable) SetTask(v string) error {
	return capnp.Struct(s).SetText(5, v)
}

func (s TaskHashable) Outputs() (TaskOutputs, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return TaskOutputs(p.Struct()), err
}

func (s TaskHashable) HasOutputs() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s TaskHashable) SetOutputs(v TaskOutputs) error {
	return capnp.Struct(s).SetPtr(6, capnp.Struct(v).ToPtr())
}

// NewOutputs sets the outputs field to a newly
// allocated TaskOutputs struct, preferring placement in s's segment.
func (s TaskHashable) NewOutputs() (TaskOutputs, error) {
	ss, err := NewTaskOutputs(capnp.Struct(s).Segment())
	if err != nil {
		return TaskOutputs{}, err
	}
	err = capnp.Struct(s).SetPtr(6, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s TaskHashable) PassThruArgs() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasPassThruArgs() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s TaskHashable) SetPassThruArgs(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(7, v.ToPtr())
}

// NewPassThruArgs sets the passThruArgs field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewPassThruArgs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(7, l.ToPtr())
	return l, err
}
func (s TaskHashable) Env() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasEnv() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s TaskHashable) SetEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(8, v.ToPtr())
}

// NewEnv sets the env field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(8, l.ToPtr())
	return l, err
}
func (s TaskHashable) ResolvedEnvVars() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasResolvedEnvVars() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s TaskHashable) SetResolvedEnvVars(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(9, v.ToPtr())
}

// NewResolvedEnvVars sets the resolvedEnvVars field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewResolvedEnvVars(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(9, l.ToPtr())
	return l, err
}
func (s TaskHashable) PassThruEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(10)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasPassThruEnv() bool {
	return capnp.Struct(s).HasPtr(10)
}

func (s TaskHashable) SetPassThruEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(10, v.ToPtr())
}

// NewPassThruEnv sets the passThruEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewPassThruEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(10, l.ToPtr())
	return l, err
}
func (s TaskHashable) EnvMode() (string, error) {
	p, err := capnp.Struct(s).Ptr(11)
	return p.Text(), err
}

func (s TaskHashable) HasEnvMode() bool {
	return capnp.Struct(s).HasPtr(11)
}

func (s TaskHashable) EnvModeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(11)
	return p.TextBytes(), err
}

func (s TaskHashable) SetEnvMode(v string) error {
	return capnp.Struct(s).SetText(11, v)
}

func (s TaskHashable) DotEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(12)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasDotEnv() bool {
	return capnp.Struct(s).HasPtr(12)
}

func (s TaskHashable) SetDotEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(12, v.ToPtr())
}

// NewDotEnv sets the dotEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewDotEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(12, l.ToPtr())
	return l, err
}

// TaskHashable_List is a list of TaskHashable.
type TaskHashable_List = capnp.StructList[TaskHashable]

// NewTaskHashable creates a new list of TaskHashable.
func NewTaskHashable_List(s *capnp.Segment, sz int32) (TaskHashable_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 13}, sz)
	return capnp.StructList[TaskHashable](l), err
}

// TaskHashable_Future is a wrapper for a TaskHashable promised by a client call.
type TaskHashable_Future struct{ *capnp.Future }

func (f TaskHashable_Future) Struct() (TaskHashable, error) {
	p, err := f.Future.Ptr()
	return TaskHashable(p.Struct()), err
}
func (p TaskHashable_Future) Outputs() TaskOutputs_Future {
	return TaskOutputs_Future{Future: p.Future.Field(6, nil)}
}

type TaskOutputs capnp.Struct

// TaskOutputs_TypeID is the unique identifier for the type TaskOutputs.
const TaskOutputs_TypeID = 0xd58300fce8aba267

func NewTaskOutputs(s *capnp.Segment) (TaskOutputs, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TaskOutputs(st), err
}

func NewRootTaskOutputs(s *capnp.Segment) (TaskOutputs, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TaskOutputs(st), err
}

func ReadRootTaskOutputs(msg *capnp.Message) (TaskOutputs, error) {
	root, err := msg.Root()
	return TaskOutputs(root.Struct()), err
}

func (s TaskOutputs) String() string {
	str, _ := text.Marshal(0xd58300fce8aba267, capnp.Struct(s))
	return str
}

func (s TaskOutputs) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TaskOutputs) DecodeFromPtr(p capnp.Ptr) TaskOutputs {
	return TaskOutputs(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TaskOutputs) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TaskOutputs) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TaskOutputs) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TaskOutputs) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TaskOutputs) Inclusions() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s TaskOutputs) HasInclusions() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TaskOutputs) SetInclusions(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewInclusions sets the inclusions field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskOutputs) NewInclusions(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s TaskOutputs) Exclusions() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s TaskOutputs) HasExclusions() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TaskOutputs) SetExclusions(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewExclusions sets the exclusions field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskOutputs) NewExclusions(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// TaskOutputs_List is a list of TaskOutputs.
type TaskOutputs_List = capnp.StructList[TaskOutputs]

// NewTaskOutputs creates a new list of TaskOutputs.
func NewTaskOutputs_List(s *capnp.Segment, sz int32) (TaskOutputs_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[TaskOutputs](l), err
}

// TaskOutputs_Future is a wrapper for a TaskOutputs promised by a client call.
type TaskOutputs_Future struct{ *capnp.Future }

func (f TaskOutputs_Future) Struct() (TaskOutputs, error) {
	p, err := f.Future.Ptr()
	return TaskOutputs(p.Struct()), err
}

const schema_e1dde60149aeb063 = "x\xdat\xd2?h\x13Q\x1c\x07\xf0\xef\xf7]\x92K" +
	"\xdb\xd46\xbc\x03\x1d\x9c\x9cTP\x14\x9d\xba\xd8J*" +
	"u\xd06^q(\x15\xbc&\xcf\\l\xb8\x0byI" +
	"l\xa7Z\xff\x80\x8a\x8b\xd0\xc1\xa1\x82J\x05Q\x10G" +
	"\x17A\x1c\x9d\x14t\x94R\x10\xa9\xe8\xa0C\x07\xa1\x10" +
	"\xf9ES\xb1\xc1\xe9\xee>\xef\xf7\xee\xf7\xe5\xbd\xdf\xa1" +
	"\xf3\x1cN\x1c\xee\xdf\xa9\xa0\xf2\xbb\x92\xa9\xd5\xd2\xc3\xa7" +
	"\xeb\x9bW?d3l\x15\x9e?;\xc9\xcf\x1f\xd7\x90" +
	"T.\x90\xfd\xf1:\xfbS\x9e\x1b\x97\xc0\xd6\xfc\xa7\x8d" +
	"\xd3_\x97\xbf\xaf\xe1\xdf\xc2~\x17\xd0\xf3|\xa3\xaf\xd3" +
	"\x05\x8e,rU\xe1@\xabZ\x8b\xeb\xf1\xc1B\xa0\xaa" +
	"Quh2\xb0\xb3\xe3\x8dz\xb5Q\xb7\x98 \xf3i" +
	"'\x01$\x08d\xf7M\x01\xf9\xbd\x0e\xf39\xc5,\xe9" +
	"QpDp\xd8a~Z\xb1U\x8e\x0a\x95\x86-\xc7" +
	"p\"\xcb\x1d\xe0\x84Cf\xa0\xe4\xb5e\xe6\xfe\xbf\xd6" +
	"\x15`,\xb0a0S1hG8\xda\x89\xa0\xcfq" +
	"\x0a\xf0\xa7\xe9\xd0\x0f\xf97\x856|\x02\xf8\xa1\xf85" +
	"q\xa5<*@/\xb6\xeb/\x8b\xdf\x16w\x1c\x8f\x0e" +
	"\xa0or\x06\xf0o\x88/\x89'\x12\x1e\x13\x80\xbe\xc3" +
	"[\x80\xbf$~_<\x99\xf4\x98\x04\xf4=\xee\x07\xfc" +
	"\xbb\xe2+\xe2\xa9\x94\xc7\x14\xa0\x1f\xf08\xe0/\x8b?" +
	"\x16w]O\x0eV?\xe2E\xc0_\x11\x7f%\x9eN" +
	"{L\x03\xfa%\xf7\x00\xfe\x0b\xf1\xf7\xe2==\x1e{" +
	"\x00\xfd\x8eW\x00\xff\xad\xf87\xf1\xde^\x8f\xbd\x80\xfe" +
	"\xd2\xce\xb9.\x9eP\x8a\xd9\xbe>\x8f}\x80\xa6\x92\xbe" +
	"\x9b\xe2i\xf1L\xc6c\x06\xd0I5\x04\x9cQ\x0e\xfd" +
	"\xddJ\xb1U\xaa\xc43Ae,\x80c\xc3\xf6ag" +
	"\xc0V=\xb0\xb39S5\x8c\x8a&*\xcc\x8f\x05\x03" +
	"64\xddW\x12\x14f\x83\x92\xc9\xc1)\xd7\xb6\xb6\x86" +
	"\x81\x0d\xc7/\x9c(\xc3\xad\x18\xbb\xa5f\xaenjQ" +
	"Pa\xceT\xad\xdc\x1c\xd0Y\x1b\x90f\x9d\x8f\x85\xf8" +
	"\xf7Xq\xb03\xc5 \x07\xdb\xbd\xac\x9d\x0ck\x0d\x0c" +
	"\x8c\xd4J\xdb\x93\xb8&jn\x0fW36\xae4M" +
	"\x91\xa3Q\xf3lP\xb3\xe8N\xff\xe7\x8f\xeeh\xd7\xee" +
	"\x05\x135O\xc5E\xd3\x89u\xac\x18\xd7\xbb\xab~\x05" +
	"\x00\x00\xff\xff49\xb6\xe2"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_e1dde60149aeb063,
		Nodes: []uint64{
			0xd58300fce8aba267,
			0xe1f09ceb4ef5e479,
		},
		Compressed: true,
	})
}
